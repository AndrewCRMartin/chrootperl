<html>
<!-- **************************************************************
       This HTML file is designed to be processed with 'bootify'
     ************************************************************** -->
<head>
<title>Perl interpreter</title>
<style type='text/css'>
pre, samp {background: #DDDDDD;
      border: 1pt solid #CCCCCC;
      border-radius: 5pt;
      padding: 1pt;
}
pre {padding: 5pt 20pt;}
samp {padding: 1pt 5pt;}
</style>
</head>
<body>

<!-- [page menu='Home'] -->

<!-- [bigheading] -->
<h1>BIOC3010</h1>
<h2>An introduction to using Perl in Bioinformatics</h2>
<p>A brief introduction to the Perl programming language and its
  application in Bioinformatics</p>
<!-- [/bigheading] -->


<h2>What is Perl?</h2>

<p>Perl stands for 'Practical Extraction and Reporting Language'. It
is designed as a powerful scripting language making it easy and fast
  to implement programs. In particular it is very good at manipulating
  data in files - extracting and reformatting data. It has built in
  functions that make it easy to read lines from a file, split them
  into columns, and to match patterns or 'regular expressions'</p>

<p>Perl is itself a program known as an 'interpreter'. It reads the
  Perl script that you write, interprets the commands that you have
  given and runs them on any data files that you have provided. The
  Perl interpreter is already installed if you are using a Linux
  machine or a Mac - you access it by opening a command line prompt
  (or 'terminal'). If you are using Windows, then you can download and
  install versions of Perl such
  as <a href='http://www.activestate.com/activeperl'
  target='links'>ActivePerl</a> or
  <a href='http://strawberryperl.com/' target='links'>Strawberry
  Perl</a> which can be used in the same way. (Even better, stop using
  Windows and install Linux instead!) </p>

<p>To write a Perl script, one normally uses a 'text editor' to create
  the script. A text editor is a program a bit like a word processor,
  but it doesn't do anything fancy like different fonts, text size,
  colours, etc. It simply allows one to create a plain text
  file. You <emph>could</emph> use Word to do that (and select 'Save
  As Plain text'), but it isn't recommended. Under Windows, you can
  use something like 'notepad', but there are better editors available
  such
  as <a href='https://notepad-plus-plus.org/' target='links'>NotePad++</a>,
  <a href='http://www.ssesetup.com/textmorph.html' target='links'>TextMorph</a>,
  <a href='http://www.pspad.com/en/' target='links'>PSPad</a>,
  <a href='http://jedit.org/' target='links'>JEdit</a>,
  <a href='https://wiki.gnome.org/Apps/Gedit' target='links'>gEdit</a> or
  <a href='http://ftp.gnu.org/gnu/emacs/windows/emacs-22.3-bin-i386.zip' target='links'>emacs</a>.
  Many of these are also available for Mac and Linux. Emacs is the
  most powerful editor and can do pretty much anything, but may be a
  little harder to learn to use.</p>

<p>Once you have created your program as a text file, you then run it
  through the Perl interpreter and pass any other files or commands
  to the script on the command line. Perl scripts do not (usually) have
  graphical interfaces, so you need to get used to using the command
  line!</p>

<!-- [information] -->
<p>In this practical, we have created a simple way for you to enter a
  Perl script via a web page and run it over the web. The same text file
  will always be given to the script as input. This is purely
  for this teaching exercise. Once you have learned the basics this
  way, you should use a version of Perl installed on your own
  machine.</p>
<!-- [/information] -->

<!-- [/page] -->

<!-- [page menu='Files'] -->

<h2>Reading a file</h2>
<p>We are going to start with a very simple program that reads the
  contents of a file and prints it to the screen. The file you are
  going to look at is a PDB file containing the structure of a protein.</p>

<p>Perl provides a very simple way of accessing a file - you simply
  provide the name of the file on the command line after the name of
  the perl script. Something like:</p>

<pre>
perl myscript.pl myfile.dat
</pre>

<p>The Perl scripting language itself provides a simple way of looping through the lines
  contained in the file. In your Perl script, you simply do:</p>

<pre>
while(&lt;&gt;)
{
   # Do something here
}
</pre>

<p>The <samp>while()</samp> control statement means 'while something
  (contained in the parentheses) is true do whatever is between the
  curly brackets'.</p>

<p>In this case the condition (the thing that has to be true) is
  written as <samp>&lt;&gt;</samp>. This is a bit of Perl shorthand
  magic that says 'read a line from the file specified on the command
  line, store the result and return FALSE if the file has ended'.</p>

<p>The thing between the curly brackets in this case is introduced
  with a <samp>#</samp> - this introduces a comment. It doesn't do anything at all,
  but allows you to help explain what your code is doing - it just makes things
  more readable.</p>

<p>So if we introduce just one more command, we will have a Perl
  script that can read a file and print its contents to the
  screen. That command is <samp>print</samp>. In Perl we put a
  semi-colon (<samp>;</samp>) after a command to indicate the end of one
  command and separate if from the next command.</p>
   
<!-- [callout] -->
<p>So here is our complete piece of code. Click the 'Run' button to
  see the results.</p>
<!-- [/callout] -->

<form action='perl.cgi' method='post'>
<textarea cols='80' rows='5' name='script'>
while(<>)
{
    print;
}
</textarea>
<input type='submit' value='Run' />
</form>

<!-- [/page] -->
<!-- [page menu='PDB'] -->

<h2>PDB Files</h2>

<p>The file that you have looked at is a PDB file. Here is a small
  snippet of the file:</p>

<pre>
ATOM      9  N   ASP L   1      17.203 -13.024  34.883  1.00 38.78           N  
ATOM     10  CA  ASP L   1      16.553 -12.738  33.612  1.00 34.98           C  
ATOM     11  C   ASP L   1      15.132 -13.283  33.573  1.00 31.72           C  
ATOM     12  O   ASP L   1      14.927 -14.498  33.516  1.00 30.05           O  
ATOM     13  CB  ASP L   1      17.376 -13.328  32.457  1.00 35.50           C  
ATOM     14  CG  ASP L   1      16.627 -13.314  31.129  1.00 37.37           C  
ATOM     15  OD1 ASP L   1      15.926 -12.321  30.839  1.00 34.69           O  
ATOM     16  OD2 ASP L   1      16.754 -14.296  30.362  1.00 35.49           O  
ATOM     17  N   ILE L   2      14.151 -12.385  33.618  1.00 27.04           N  
ATOM     18  CA  ILE L   2      12.755 -12.798  33.565  1.00 24.06           C  
ATOM     19  C   ILE L   2      12.335 -12.897  32.106  1.00 23.36           C  
ATOM     20  O   ILE L   2      12.305 -11.898  31.377  1.00 21.75           O  
ATOM     21  CB  ILE L   2      11.835 -11.799  34.294  1.00 23.42           C  
ATOM     22  CG1 ILE L   2      12.257 -11.685  35.767  1.00 24.39           C  
ATOM     23  CG2 ILE L   2      10.384 -12.263  34.194  1.00 22.99           C  
ATOM     24  CD1 ILE L   2      11.437 -10.700  36.576  1.00 23.75           C  
</pre>

<p>Note that a PDB file resulting from x-ray crystallography does not
  normally contain the positions of the hydrogen atoms, since these
  can't usually be seen in the structure.</p>

<p>For the purposes of this exercise, you can assume that the file
  contains 12 columns, each of which is separated by a space.</p>

<ul>
<li>The first column is simply a label that tells us what sort of data
  are in this line or 'record' in the file. I've edited the file down
  so that we only have the 'ATOM' records which represent the
  coordinates of the protein - the full file has various
  header information as well 'HETATM' records that represent
  non-protein atoms such as waters.</li>

<li>The second column is a record number - it is simply a unique number
  for each ATOM record.</li>

<li>The third column is the atom type indicating its position within an
  amino acid</li>

<li>The fourth column is the amino acid type.</li>
<li>The fifth column is the chain label - PDB files can contain
  quaternary structure, or complexes between proteins or simply
  multiple copies of the same protein. Each protein chain is given a
  different chain label.</li>
<li>The sixth column is the amino acid number counting from the
  N-terminus of each chain. These numbers can be zero or even
  negative and in some cases can have a letter following the numbers.</li>
<li>The seventh, eighth and ninth columns represent the x,y,z
  coordinates of the atom</li>
<li>The tenth column is the occupancy. This is normally 1.0, but in
  some cases, an atom can be flipping between two (or more) different
  distinct positions. This is indicated by having multiple records
  for the atom with the occupancy indicating the fraction of time
  that the atom spends at that position.</li>
<li>The eleventh column is the 'temperature factor' or 'B-value'. This
  indiates the amount of thermal motion that the atom has - in other
  words how much it is vibrating about the indicated position.</li>
<li>The twelfth column represents the element type.</li>
</ul>

<!-- [/page] -->
<!-- [page menu='Scalars'] -->

<h2>Scalar variables</h2>

<p>Let's modify our program so that instead of printing the contents
  of the file, we count the number of lines in the file. To do this we
  need to have what is known as a 'scalar variable'. A bit like in
  algebra this is a way of storing a number or a string (a set of
  characters) in a 'variable'. We introduce scalar variables with
  a <samp>$</samp>, so we can say something like:</p>

<pre>
$total = 0;
</pre>

<p>Note that the equals sign is used for assignment not for equality
  as it is in algebra. The statement means 'set the
  variable <samp>$total</samp> to the value zero.<p>

<p>Since the equals sign is used for assignment not for equality, we
  can also say things like:</p>

<pre>
$total = $total + 1;
</pre>

<p>This will increment the value of <samp>$total</samp> i.e. set it to
  one more than it was previously. In fact this is such a common thing
  to do that there is a special shorthand syntax for doing it:</p>

<pre>
$total++;
</pre>

<p>One other piece of information. You can print things other than the
  current line (which we did simply with <samp>print;</samp>) such as
  pieces of text and the contents of scalar variables, by putting them
  in double-inverted commas, like this:</p>

<pre>
print "The total was: $total\n";
</pre>

<p>The funny <samp>\n</samp> at the end inserts a return character to
  end the printed line.</p>

<!-- [callout] -->
<p>Clearly we can exploit all this to count the lines in a file. You now
  know everything you need:</p>
<ul>
<li>Use a variable to count the lines</li>
<li>Start by initializing the variable to zero</li>
<li>Loop through the file
  using <samp>while(<>){&nbsp;&nbsp;}</samp></li>
<li>For each iteration of the loop, increment the variable</li>
<li>After the loop has finished, print the number of lines</li>
</ul>

<p>Give it a go! The answer should be 4250</p>
<!-- [/callout] -->

<form action='perl.cgi' method='post'>
<textarea cols='80' rows='10' name='script'>
</textarea>
<input type='submit' value='Run' />
</form>

<!--
<pre>
$total = 0;
while(<>)
{
    $total++;
}
print "There were $total lines\n";
</pre>
-->

<div><br /></div>

<!-- [warning] -->

<p>Did it work or did you get no answer back?</p>

<p>Sometimes you might see nothing at all or nothing where you
  expected to see something. The most likely reason for this is that
  you misspelled a variable name.</p>

<p>Error messages from the Perl interpreter may be a little
  confusing. The main thing to look for is the line number where an
  error occurred. Look at that line to see if you can find an
  error. If not look on the two or three lines preceding it.</p>

<p>The most likely errors are:</p>

<ul>
<li>You misspelled a variable name</li>
<li>You forgot a <samp>$</samp> sign in front of a variable name</li>
<li>You forgot a <samp>;</samp> at the end of a normal statement</li>
<li>You accidentally included a <samp>;</samp> at the end of a control
  statement (e.g. <samp>while(<>); { }</samp></li>
<li>You didn't match a <samp>{</samp> with a <samp>}</samp> of
  a <samp>(</samp> with a <samp>)</samp></li>
</ul>
<!-- [/warning] -->

<!-- [/page] -->
<!-- [page menu='Arrays'] -->

<h2>Columns and arrays</h2>

<p>The PDB format has already been described and, for the purpose of
  this exercise, can be considerd as a set of columns. Perl lets you
  split a line into columns very easily. We can simply say:</p>

<pre>
@columns = split;
</pre>

<p><samp>@columns</samp> is known as an 'array' - it's a group of items
  that can be accessed with an index (i.e. a number that represents a
  'slot' in the array). Think of the array as the name of a road of houses -
  you can access the person who lives in a particular house by
  specifying the road name and the house number. The main difference
  is that, in Perl, array indices count from zero rather than
  one.</p>

<p>If, as in this example, our array is called <samp>@columns</samp>
  we could access the first column using <samp>$columns[0]</samp>, the
  second column with <samp>$columns[1]</samp>, etc.</p>

<p> Notice that we refer to a whole array by putting an <samp>@</samp>
  in front of the name of the array - using the road of houses
  analogy, this is how we show we are referring to the whole
  road. However, when we refer to an individual 'slot' in the array we
  use a <samp>$</samp> in front of the name. This is because the 
  single slot is not an array. In the road of houses analogy, it is a
  single house rather than the whole road. Consequently, it is a
  scalar variable which (as shown previously) starts with
  a <samp>$</samp>.</p>

<p>We already know how to count the lines in a file - since we know
  that our data contained coordinates of a protein, this means that we
  were counting how many atoms were in the protein. Let's change this
  so we are counting how many amino acids are in the protein.</p>

<p>Every amino acid has a backbone consisting of a nitrogen (N), alpha
  carbon (CA), carbonyl carbon (C) and carbonyl oxygen (O). The names
  in parentheses are the labels used in the PDB file to refer to these
  atoms. As we work out along the side-chain, the positions are
  indicated using other letters of the Greek alphabet (beta, gamma,
  etc.) which are translated to their Roman equivalents (beta=B,
  gamma=G, etc), so an alanine (which just has a CH<sub>3</sub> group
  attached to the C-alpha), has a C-beta atom (CB in the PDB file).</p> 

<p>Looking at the PDB format, we saw that the atom type is indicated
  in the third column. If we store the columns in an array
  called <samp>@columns</samp> then we can access the third column
  using <samp>$columns[2]</samp></p>

<p>Consequently, since each and every amino acid only has one
  occurrence of a C-alpha, we could count the number of amino acids,
  by counting the number of times that 'CA' occurs
  in <samp>$columns[2]</samp>.</p>

<p>Now we need to introduce two new programming concepts.</p>

<ol>
<li>Just as we had a <samp>while(){}</samp> loop which executed a set of
  statements (enclosed in the curly brackets) <i>while</i> something
  was true, we can use an <samp>if(){}</samp> statement to execute
  some code just once <i>if</i> something is true.</li>
<li>We can test whether a variable contains a certain string using
  the <samp>eq</samp> test.</li>
</ol>

<p>Putting this information together we can test whether we are
  looking at a C-alpha by doing:</p>

<pre>
if($columns[2] eq "CA")
</pre>

<!-- [callout] -->
<p>Your previous code that counted the total number of atoms should
  have looked like what is shown below. Modify it to count the number
  of amino acids. The answer should be 555</p>
<!-- [/callout] -->

<form action='perl.cgi' method='post'>
<textarea cols='80' rows='7' name='script'>
$total = 0;
while(<>)
{
    $total++;
}
print "There were $total atoms\n";
</textarea>
<input type='submit' value='Run' />
</form>

<!--
$total = 0;
while(<>)
{
   @columns = split;
   if($columns[2] eq "CA")
   {
      $total++;
   }
}
print "There were $total residues\n";
-->

<!-- [/page] -->

<!-- [page menu='Loops'] -->

<h2>Loops and arrays</h2>

<p>
You have already seen the <samp>while(){}</samp> loop used to repeat a
block of code <i>while</i> something is true (in the cases you have
seen, the thing you are testing for truth is whether the file contains
something - i.e. we haven't reached the end of the file).  Very often
we want to do something a specified number of times and we can use
the <samp>while(){}</samp> loop for this purpose.</p>

<!-- [callout] -->
<p>For example, if we wanted to do something 5 times, we could
initialize a variable to zero, (e.g. <samp>$count=0;</samp>) start
a <samp>while(){}</samp> with the condition that the variable is less
than 5 and within the loop we could increment the variable. Give it a
try:</p>
<!-- [/callout] -->


<form action='perl.cgi' method='post'>
<textarea cols='80' rows='7' name='script'>
$count = 0;
while($count &lt; 5)
{
   print "Hello\n";
   $count++;
}
</textarea>
<input type='submit' value='Run' />
</form>

<p>However, this is something that we need to do so often, that Perl
  gives us a simpler syntax known as the <samp>for(){}</samp>
  loop.</p>

<!-- [callout] -->
<p>This allows us to specify an initialization, a condition and
  an increment in a single line. Give it a try:</p>
<!-- [/callout] -->

<form action='perl.cgi' method='post'>
<textarea cols='80' rows='5' name='script'>
for($count = 0; $count < 5; $count++)
{
   print "Hello\n";
}
</textarea>
<input type='submit' value='Run' />
</form>

<p>Mathematically arrays can be thought of as being like a vector, but
  in Perl, arrays are rather interchangeable with 'lists'. A list is a
  set of values separated by commas and enclosed in
  parentheses. e.g.</p>

<pre>
(1, 2, 3, 4, 5);
</pre>

<p>This equivalence allows us to initialize the values in an
  array. For example:</p>

<pre>
@words = ("Hello", "World");
</pre>

<p>We could use a <samp>for(){}</samp> loop to print each of the
  values in an array. You just need one other piece of information to
  know how to do that: how to find out how many values are in
  the array.</p>

<!-- [callout] -->
<p> Perl lets you do that by using the <samp>scalar()</samp>
  function around the array name. Try this piece of code:</p>
<!-- [/callout] -->

<form action='perl.cgi' method='post'>
<textarea cols='80' rows='5' name='script'>
@words = ("Hello", "World");
$nWords = scalar(@words);
print "There were $nWords words\n";
</textarea>
<input type='submit' value='Run' />
</form>

<!-- [callout] -->
<p>Given the information you have about the <samp>for(){}</samp> loop,
  and remembering how you access an individual item in an array,
  modify the above code to print each word in the array on a separate
  line.</p>
<!-- [/callout] -->

<p>Again stepping through the values contained in an array is such a
  common thing, that Perl provides a special loop syntax for doing
  it. This is known as the <samp>foreach(){}</samp> loop:</p>

<form action='perl.cgi' method='post'>
<textarea cols='80' rows='7' name='script'>
@words = ("Hello", "World");
foreach $word (@words)
{
    print "$word\n";
}
</textarea>
<input type='submit' value='Run' />
</form>

<!-- [callout] -->
<ul>
<li>What happens if you take out the <samp>\n</samp>?</li>
<li>Modify this code so that you also count how many words were stored
  in the array as you step through the loop and print the answer.</li>
</ul>
<!-- [/callout] -->


<!-- [/page] -->
<!-- [page menu='Hashes'] -->

<h2>Hashes</h2>
<p>We have so far met two ways of storing data:</p>

<p>1. The <b>scalar variable</b>: This is introduced by a <samp>$</samp>
  and is used to store a single value which can be a number or a
  string of characters. For instance:
</p>
<form action='perl.cgi' method='post'>
<textarea cols='80' rows='5' name='script'>
$a = 5;
$b = "Hello world";
print "The value of 'a' was $a\n";
print "'b' says $b\n";
</textarea>
<input type='submit' value='Run' />
</form>

<p>2. The <b>array</b>: This is introduced by an <samp>@</samp> and
  allows us to store a group of values together under a single label,
  accessing each one using an index number. Remember that an
  individual slot in the array (as opposed to the whole array) is a
  scalar and is therefore introduced by a <samp>$</samp>. For instance:</p>
<form action='perl.cgi' method='post'>
<textarea cols='80' rows='3' name='script'>
@values = ("Zero", "One", "Two", "Three");
print "$values[2]\n";
</textarea>
<input type='submit' value='Run' />
</form>

<div><br /></div>

<p>There is a third way of storing data known as the 'hash'. This is
  like an array, but instead of using an integer as an index to find
  an individual (scalar) value as is done in an array, we use a string
  as an index (or 'key') into the hash. To extend the analogy of a
  road of houses, while an array has houses with numbers, a hash is a
  posh private road which has houses with names instead of numbers. We
  refer to a whole hash by introducing its name with a <samp>%</samp>.
  There is one other difference from arrays: in an array, we place the
  index in square brackets <samp>[&nbsp;]</samp> while in a hash, we
  place the key in curly brackets <samp>{&nbsp;}</samp>.
</p>

<p>One other thing you need to know when using hashes - how do you
  know what 'keys' have been used? With an array you know that the
  indices are numbers starting from zero and counting upwards. With a
  hash, the keys could be anything. Perl provides a function called
  (suprisingly!) <samp>keys</samp> which takes a whole hash and
  returns an array containing the keys. e.g.</p>

<pre>
@theKeys = keys %myHash;
</pre>

<p>You can then step through that array in the usual ways (e.g. using
  a <samp>foreach(){}</samp> loop) to access each key in turn. You
  don't have to place the keys into an array explicitly, so you can do
  something like:</p>

<pre>
foreach $key (keys %myHash)
{
   # Do something here
}
</pre>

<!-- [callout] -->
<p>Here is a little example that takes a piece of text, splits it into
  words (storing these in an array) and then uses those words as keys
  in a hash to count how many times each word occurs.</p>
<!-- [/callout] -->

<form action='perl.cgi' method='post'>
<textarea cols='80' rows='20' name='script'>
# Initialize a string with some text
$text = "Once upon a time there was a man who had a time machine";
# Split it up into words
@words = split(/\s+/, $text);

# Step through the words, using each as a key to a hash and
# incrementing the number stored at that slot in the hash
foreach $word (@words)
{
    $wordCounts{$word}++;
}

# Step through the keys of the hash (the words) and for each, 
# print the word and the count
foreach $word (keys %wordCounts)
{
   print "$word: $wordCounts{$word}\n";
}
</textarea>
<input type='submit' value='Run' />
</form>

<div><br /></div>

<p>This has introduced a small variation on the <samp>split()</samp>
  function. Previously we just used it by itself - this splits what is
  known as the 'default variable' (a special scalar variable that is
  used for things like reading a file if you don't specify anything
  else) and splits it at white space. Here we need to split something
  different (the string containing the text), so we have to give that
  as a parameter to the <samp>split</samp> function. Unfortunately it
  has to be the second parameter - the first parameter
  specifies <i>where</i> we split. We have to provide a pattern of
  characters where we have to make the split - these patterns are
  known as 'regular expressions' and are enclosed in two forward
  slashes: <samp>/&nbsp;/</samp>. The regular expression contains two
  elements: <samp>\s</samp> which matches any type of whitespace
  (normal spaces, tabs and line breaks) and <samp>+</samp> which
  indicates 'one-or-more' of the thing that came before it in the
  regular expression. In other words, this will split on one-or-more
  whitespaces so both:</p>
<pre>
One Two Three
</pre>
and 
<pre>
One      Two              Three
</pre>
<p>would be split into an array containing the values "One", "Two" and
"Three".</p>

<p>We have seen how we can use hashes, so let's apply them to obtain a
  list of the <i>chains</i> present in our PDB file. If we read our PDB file as
  before and split each line into columns, we can use the chain label (stored
  in <samp>$columns[4]</samp>) as a key into a hash. In this case the
  value we store doesn't matter: each time we read another line from
  the file we will overwrite the value that is stored. All we care
  about is the list of keys.</p>

<!-- [callout] -->
<p>Go ahead and see if you can write the code. Remember what you
  need:</p>
<ol>
<li>Read the file a line at a time with a <samp>while(<>){}</samp>
  loop.</li>
<li> For each line...</li>
     <ul>
     <li>Split each line using <samp>split</samp></li>
     <li>Use the chain label stored in <samp>$columns[4]</samp> as the key
         of a hash, setting the value to whatever you like (e.g. to
         1)</li>
     </ul>
<li>Once the file is fully read, obtain the keys of the hash and print
  them</li>
</ol>

<p>I've provided an outline with some comments describing the code you
  need to write:</p>
<!-- [/callout] -->

<form action='perl.cgi' method='post'>
<textarea cols='80' rows='15' name='script'>
while(<>)
{
    # Split the line into columns

    # Use $columns[4] as the key to a hash - store the number 1 as the value

}
# Obtain the keys of the hash

# Print the keys
</textarea>
<input type='submit' value='Run' />
</form>

<!-- [callout] -->
<p>Now modify the code so that you obtain:</p>
<ul>
<li>First, the number of atoms in each chain (rather than storing 1 as
  the value in the hash, increment the value and print it at the
  end)</li>
<li>Second, the number of residues in each chain (the same as counting
  the atoms, but we check that <samp>$columns[2]</samp>
  is <samp>CA</samp>)</li>
</ul>
<!-- [/callout] -->

<!-- [/page] -->

<!-- [page menu='Summary'] -->
<h2>Summary</h2>

<p>This tutorial has given you an introduction to the main data
  structures, flow control statements and syntax of Perl. The Perl
  setup on these web pages is deliberately crippled - there are lots
  of things that you could do with Perl that you can't do on this
  version.</p>

<p>Learning to program is an essential skill for Bioinformatics -
  should you wish to take things further, you are recommended to start
  using Perl on your own machine. If you are using a Mac or Linux, you
  are in luck as Perl is already installed - you just need to learn to
  use the command line and a text editor. If you are using Windows,
  then you need to install
  <a href='http://www.activestate.com/activeperl' target='links'>ActivePerl</a> or
  <a href='http://strawberryperl.com/' target='links'>Strawberry
  Perl</a>.</p>

<p>There is also an online Perl interpreter that you can play with at
<!-- [link] -->http://www.tutorialspoint.com/execute_perl_online.php<!-- [/link] -->.</p>

<p>There is a good Perl resource at
<!-- [link] -->http://wiht.link/perl-resources<!-- [/link] -->.
</p>

<p>There are several good books on Perl - some aimed specifically at
  Bioinformatics:</p>

<ul>
<li>"Beginning Perl for Bioinformatics" by James Tisdall 
(O'Reilly Media; 1st edition; 2001) ISBN-13: 978-0596000806</li>
<li>"Bioinformatics, Biocomputing and Perl: An Introduction to
Bioinformatics Computing Skills and Practice" by Michael Moorhouse and
Paul Barry (John Wiley & Sons; 1st edition; 2004) ISBN-13: 978-0470853313
</li>
<li>"Learning Perl" by Randal L. Schwartz, Brian D Foy and Tom Phoenix
(O'Reilly Media; 6th edition; 2011) ISBN-13: 978-1449303587</li>
<li>"Beginning Perl (Wrox Programmer to Programmerwrox Beginning Guides)"
by Curtis Poe (WROX Press Ltd; 1st edition; 2012) ISBN-13: 978-1118013847</li>
<li>"Beginning Perl (Programmer to Programmer)"
by Simon Cozens (WROX Press Ltd; 2000) ISBN-13: 978-1861003140</li>
</ul>

<p>You may also have heard of other programming languages such as
  R and Python. R is a specialist language designed for statistics
  although it can be persuaded to do many other things. Python is a
  general purpose language like Perl. Like any language, it has
  advantages and disadvantages - while it is quite popular in many
  areas including Bioinformatics, in my opinion, the disadvantages
  currently out-weigh the advantages. Ask me if you want to know
  why!</p>

<p>Your opinions on this practical are welcome!</p>

<!-- [/page] -->


</body>

